(ns ^{:author "Paul Cichonski"
      :doc "Provides the functionality to read an OWL ontology encoded in RDF/XML syntax. 
            This ns provides one primary functions for interacting with it, the 'classes-and-relationships'
            function will return back a map containing the namespace declarations of the OWL file and 
            the classes and relationships contained within the OWL ontology file. 
     "
     }
     owl-util.reader.owlXmlReader
  (:require [owl-util.reader.core :as reader-core]
            [clojure.zip :as zip]
            [clojure.xml :as xml]
            [clojure.contrib.zip-filter.xml :as zip-xml]
            [clojure.contrib.zip-filter :as zf]
            [clojure.string]))
; using the xml zipper strategy illustrated here: http://nakkaya.com/2009/12/07/zipping-xml-with-clojure/

;; static namespace associations for OWL, RDF, RDFS
(def static-namespaces {:rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                 :rdfs "http://www.w3.org/2000/01/rdf-schema#"
                 :owl "http://www.w3.org/2002/07/owl#"})

;; namespace resolution functions to help keep code working regardless of qnames declared in xml
(defn- resolve-qname-prefix [ideal-prefix namespaces]
  "Returns the actual qname prefix  (how it appears in the target xml) 
for the passed in ideal-prefix (with each ideal-prefix being defined 
in the static-namespace map)."
  (letfn [(find-qname [namespace-map target-ns] 
                      ;; assuming only one ns will match target-ns
                      (key (first (filter (fn [[key val]] (if (= val target-ns) key)) namespace-map))))]
         (case ideal-prefix
           :rdf (let [rdf-ns (static-namespaces :rdf)]
                  (find-qname namespaces rdf-ns))
           :rdfs (let [rdfs-ns (static-namespaces :rdfs)]
                  (find-qname namespaces rdfs-ns))
           :owl (let [owl-ns (static-namespaces :owl)]
                  (find-qname namespaces owl-ns)))))


(defn- gen-owl-keyword [name namespaces]
  "helper function to generate qname neutral OWL keywords"
  (keyword (clojure.string/replace-first (str (resolve-qname-prefix :owl namespaces) ":" name) #":" "")))

(defn- gen-rdfs-keyword [name namespaces]
  "helper function to generate qname neutral RDFS keywords"
  (keyword (clojure.string/replace-first (str (resolve-qname-prefix :rdfs namespaces) ":" name) #":" "")))

(defn- gen-rdf-keyword [name namespaces]
  "helper function to generate qname neutral RDF keywords"
  (keyword (clojure.string/replace-first (str (resolve-qname-prefix :rdf namespaces) ":" name) #":" "")))

;; XML-centric functions
(defn- create-xml-ontology [fileLocation]
  "Return the XML representation of the ontology for access using zip-xml/xml->"
  (->> fileLocation java.io.File. xml/parse zip/xml-zip))

(defn- find-namespaces [xml-ont]
  "returns a map of namespace declarations from the xml-ont, key is namespace prefix, value is URI.
note: default namespace has a blank ':' keyword, which may need to be generated by a call to (keyword ""))."
  (letfn [(extract-prefix [[xml-prefix ns]]
                          "function to extract the xml bits like xmlns from the prefix, will return a map entry containing the prefix and ns - will return a blank keyword for the default namespace"
                          (let [xml-prefix (str xml-prefix)
                                prefix (cond (re-matches #":xmlns:.*" xml-prefix) 
                                             (keyword (str (second (re-find #":(?:\S+):(\S+)" xml-prefix))))
                                             (re-matches #":xmlns" xml-prefix) 
                                             (keyword "")
                                             :else (throw (Exception. 
                                                            (str "namespace declaration " xml-prefix " in a format that was not expected"))))]
                            [prefix ns]))]
         (reduce conj 
                 {} 
                 (map extract-prefix 
                      (zip-xml/xml-> xml-ont (zip-xml/attr 
                                               ;; returns all attributes that contain namespace declarations.
                                               #(filter (fn [[key _]] (re-matches #":xmlns.*" (str key))) %)))))))

(comment "this function assumes classes are being defined in a default ns and appends the '#' since
most tools do not seem to do that. May need to make this code a bit smarter if issues are encountered")
(defn- find-classes [xml-ont]
  "Returns the lazy sequence of maps for the OWL classes, each map 
contains the class name, and an empty list of predicates."
  (let [namespaces (find-namespaces xml-ont)
        owl-class (gen-owl-keyword "Class" namespaces)]
    (for [class (zip-xml/xml-> xml-ont owl-class (zip-xml/attr :rdf:ID))]
      {:class (str "#" class) :preds ()})))


(defn- build-pred-scraper [domain-keyword range-keyword resource-keyword]
  "Generates a function that can successfully scrape required predicate data. 
Needs the correct qname-prepared keywords to build the function."
  (fn [pred]
    "takes in a zip-xml structure of an OWL/XML predicate and scrapes out necessary keys"
    (let [type ((zip/node pred) :tag) ; a bit ugly b/c it escapes from zip-xml native structure
          id (zip-xml/xml-> pred (zip-xml/attr :rdf:ID))
          domain (zip-xml/xml-> pred domain-keyword (zip-xml/attr resource-keyword))
          range (zip-xml/xml-> pred range-keyword (zip-xml/attr resource-keyword))]
      {:type type :id (first id) :domain domain :range range})))



(defn- find-object-properties [xml-ont]
  "Returns the lazy sequence of maps for the owl object properties"
  (let [namespaces (find-namespaces xml-ont)
        object-prop-keyword (gen-owl-keyword "ObjectProperty" namespaces)
        domain-keyword (gen-rdfs-keyword "domain" namespaces)
        range-keyword (gen-rdfs-keyword "range" namespaces)
        resource-keyword (gen-rdf-keyword "resource" namespaces)
        scrape-pred-data (build-pred-scraper domain-keyword range-keyword resource-keyword)]
    (map scrape-pred-data (zip-xml/xml-> xml-ont object-prop-keyword))))


(defn- find-data-properties [xml-ont]
  "Returns the lazy sequence of maps for the owl data properties"
  (let [namespaces (find-namespaces xml-ont)
        data-prop (gen-owl-keyword "DatatypeProperty" namespaces)
        domain-keyword (gen-rdfs-keyword "domain" namespaces)
        range-keyword (gen-rdfs-keyword "range" namespaces)
        resource-keyword (gen-rdf-keyword "resource" namespaces)
        scrape-pred-data (build-pred-scraper domain-keyword range-keyword resource-keyword)]
    (map scrape-pred-data (zip-xml/xml-> xml-ont  data-prop))))


(comment
  "this next part is all about map munging, need to combine each class map with the predicate maps:
add the predicate data to the class where the pred domain matches the class")
(defn- munge-c-and-p [classes pred]
  "add the predicate to the class it belongs to"
  (for [class classes]
    (if (some #{(class :class)} (pred :domain)) ;:domain is a list of all domains.
      (merge-with conj class {:preds pred})
      class)))

;; public interfaces
(defmethod reader-core/classes-and-relationships ::reader-core/XML [file-location]
  "Returns a two-key map (:namespaces & :model), where :namespaces contains a map of all ns declarations 
(key is the qname prefix, value is the namespace. note: default namespace has a blank ':' keyword, which 
may need to be generated by a call to (keyword "")).
:model contains a list of maps, where each map is a class and the predicates that 
have that class as their domain."
  (let [xml-ont (create-xml-ontology file-location)
        namespaces (find-namespaces xml-ont)
        classes (find-classes xml-ont)
        preds (concat (find-object-properties xml-ont)
                      (find-data-properties xml-ont))
        munged-c-and-p (assoc {} :model (reduce munge-c-and-p classes preds))]
    (assoc munged-c-and-p :namespaces namespaces)))


